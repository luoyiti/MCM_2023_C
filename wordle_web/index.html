<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Simulation (Web)</title>
    <script src="words.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 1000px; margin: 0 auto; }
        .container { display: flex; gap: 20px; }
        .panel { flex: 1; padding: 20px; border: 1px solid #ccc; border-radius: 8px; }
        .grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 20px; max-width: 300px; }
        .cell { 
            width: 50px; height: 50px; 
            border: 2px solid #d3d6da; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 24px; font-weight: bold; text-transform: uppercase;
        }
        .cell.green { background-color: #6aaa64; color: white; border-color: #6aaa64; }
        .cell.yellow { background-color: #c9b458; color: white; border-color: #c9b458; }
        .cell.gray { background-color: #787c7e; color: white; border-color: #787c7e; }
        
        .controls { margin-bottom: 20px; }
        input, button, select { padding: 8px; margin-right: 5px; }
        button { cursor: pointer; background-color: #eee; border: 1px solid #ccc; }
        button:hover { background-color: #ddd; }
        button.primary { background-color: #6aaa64; color: white; border: none; }
        
        .chart-container { 
            height: 300px; 
            display: flex; 
            align-items: stretch; 
            gap: 10px; 
            padding-top: 20px; 
            border-bottom: 1px solid #ccc; 
        }
        .bar-group { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-end; 
        }
        .bar { 
            width: 100%; 
            transition: height 0.2s; 
            min-height: 1px; 
            border-radius: 4px 4px 0 0;
        }
        .bar-label { margin-top: 5px; font-weight: bold; }
        .bar-value { margin-bottom: 5px; font-size: 12px; }
        
        .progress-bar { width: 100%; height: 20px; background-color: #eee; margin-top: 10px; border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background-color: #6aaa64; width: 0%; transition: width 0.1s; }
    </style>
</head>
<body>

<h1>Wordle Simulation</h1>

<div class="container">
    <!-- Left Panel: Single Game -->
    <div class="panel">
        <h2>Single Game</h2>
        <div class="controls">
            <label>Strategy: 
                <select id="strategy">
                    <option value="frequency">Frequency Priority</option>
                    <option value="entropy">Entropy Priority</option>
                    <option value="random">Random</option>
                </select>
            </label>
        </div>
        <div class="controls">
            <input type="text" id="targetWord" placeholder="Target Word" maxlength="5" style="width: 80px;">
            <button onclick="setTarget()">Set</button>
            <button onclick="setRandomTarget()">Random</button>
        </div>
        
        <div class="grid" id="grid">
            <!-- Cells generated by JS -->
        </div>
        
        <div class="controls">
            <button onclick="stepSimulation()" id="btnStep" disabled>Next Step</button>
            <button onclick="resetGame()">Reset</button>
        </div>
        <div id="status">Ready.</div>
    </div>

    <!-- Right Panel: Batch Simulation -->
    <div class="panel">
        <h2>Batch Simulation</h2>
        <div class="controls">
            <label>Count: <input type="number" id="batchCount" value="100" style="width: 60px;"></label>
            <label>Speed (ms): <input type="number" id="batchSpeed" value="10" style="width: 60px;"></label>
        </div>
        <button class="primary" onclick="startBatch()" id="btnBatch">Start Batch</button>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <h3>Results Distribution</h3>
        <div class="chart-container" id="chart">
            <!-- Bars generated by JS -->
        </div>
        <div id="batchStatus"></div>
    </div>
</div>

<script>
    // --- Game Logic ---
    
    // Helper to count characters
    function getCharCounts(word) {
        const counts = {};
        for (const char of word) {
            counts[char] = (counts[char] || 0) + 1;
        }
        return counts;
    }

    function getFeedback(guess, trueWord) {
        const feedback = Array(5).fill('gray');
        const answerCounts = getCharCounts(trueWord);
        
        // Green pass
        for (let i = 0; i < 5; i++) {
            if (guess[i] === trueWord[i]) {
                feedback[i] = 'green';
                answerCounts[guess[i]]--;
            }
        }
        
        // Yellow pass
        for (let i = 0; i < 5; i++) {
            if (feedback[i] === 'gray' && answerCounts[guess[i]] > 0) {
                feedback[i] = 'yellow';
                answerCounts[guess[i]]--;
            }
        }
        
        return feedback;
    }

    function fitGreen(acceptWord, wordsNow) {
        return wordsNow.filter(word => {
            for (let i = 0; i < 5; i++) {
                if (acceptWord[i] !== '?' && word[i] !== acceptWord[i]) return false;
            }
            return true;
        });
    }

    function fitYellow(yellowInfo, wordsNow) {
        return wordsNow.filter(word => {
            for (const [letter, forbidden] of Object.entries(yellowInfo)) {
                if (!word.includes(letter)) return false;
                for (const pos of forbidden) {
                    if (word[pos] === letter) return false;
                }
            }
            return true;
        });
    }

    function fitGray(grayLetters, yellowLetters, greenLetters, wordsNow) {
        // Pure gray: letters that are gray and NOT in yellow or green sets
        const pureGray = new Set([...grayLetters].filter(x => !yellowLetters.has(x) && !greenLetters.has(x)));
        return wordsNow.filter(word => {
            for (const letter of pureGray) {
                if (word.includes(letter)) return false;
            }
            return true;
        });
    }

    // --- Entropy Calculation ---
    function calculateEntropy(guess, possibleWords) {
        const feedbackCounts = {};
        
        // Optimization: If too many words, sample them to estimate entropy
        // Otherwise it's O(N^2) which is too slow for JS
        let sampleWords = possibleWords;
        if (possibleWords.length > 200) {
            // Random sample of 200 words
            sampleWords = [];
            for(let i=0; i<200; i++) {
                sampleWords.push(possibleWords[Math.floor(Math.random() * possibleWords.length)]);
            }
        }

        for (const trueWord of sampleWords) {
            const feedback = getFeedback(guess, trueWord);
            const key = feedback.join(',');
            feedbackCounts[key] = (feedbackCounts[key] || 0) + 1;
        }

        let entropy = 0;
        const total = sampleWords.length;
        for (const count of Object.values(feedbackCounts)) {
            const p = count / total;
            entropy -= p * Math.log2(p);
        }
        return entropy;
    }

    function runSimulationOnce(targetWord, wordsPool, strategy) {
        let yellowInfo = {};
        let grayLetters = new Set();
        let yellowLetters = new Set();
        let greenLetters = new Set();
        let acceptWord = ['?', '?', '?', '?', '?'];
        let wordsNow = [...wordsPool];
        const randomPickProb = [0.2, 0.3, 0.5];
        
        const guesses = [];
        
        if (wordsNow.length === 0) return { tries: 7, guesses };
        
        // First guess
        let guessedWord;
        if (strategy === 'entropy') {
             // First guess random to save time, or hardcode 'tares'/'soare'
             // Python code does random choice for first guess
             guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
        } else if (strategy === 'frequency') {
            let prob = randomPickProb[Math.floor(Math.random() * randomPickProb.length)];
            let topK = Math.max(1, Math.floor(wordsNow.length * prob));
            guessedWord = wordsNow[Math.floor(Math.random() * topK)];
        } else {
            // Random
            guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
        }
        guesses.push(guessedWord);
        
        for (let tryNum = 1; tryNum <= 7; tryNum++) {
            if (guessedWord === targetWord) return { tries: tryNum, guesses };
            if (tryNum === 7) return { tries: 7, guesses };
            
            const feedback = getFeedback(guessedWord, targetWord);
            
            // Update constraints
            for (let i = 0; i < 5; i++) {
                const color = feedback[i];
                const char = guessedWord[i];
                
                if (color === 'green') {
                    acceptWord[i] = char;
                    greenLetters.add(char);
                } else if (color === 'yellow') {
                    yellowLetters.add(char);
                    if (!yellowInfo[char]) yellowInfo[char] = [];
                    yellowInfo[char].push(i);
                } else {
                    grayLetters.add(char);
                }
            }
            
            // Filter candidates
            // Entropy strategy in Python code:
            // "words_now = fit_gray(gray_letters, yellow_letters, green_letters, words_now)"
            // It ONLY filters by Gray letters, ignoring Green/Yellow constraints to maximize info gain?
            // Wait, the Python code says:
            // # words_now = fit_green(accept_word, words_now)
            // # words_now = fit_yellow(yellow_info, words_now)
            // words_now = fit_gray(gray_letters, yellow_letters, green_letters, words_now)
            // So for Entropy, it relaxes constraints.
            
            if (strategy === 'entropy') {
                wordsNow = fitGray(grayLetters, yellowLetters, greenLetters, wordsNow);
            } else {
                wordsNow = fitGreen(acceptWord, wordsNow);
                wordsNow = fitYellow(yellowInfo, wordsNow);
                wordsNow = fitGray(grayLetters, yellowLetters, greenLetters, wordsNow);
            }
            
            wordsNow = wordsNow.filter(w => w !== guessedWord);
            
            if (wordsNow.length === 0) return { tries: 7, guesses };
            
            // Pick next guess
            if (strategy === 'entropy') {
                // Calculate entropy for all candidates
                // Optimization: If too many candidates, just pick random to avoid freeze
                if (wordsNow.length > 500) {
                     guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
                } else {
                    // Find max entropy
                    let maxEntropy = -1;
                    let bestWords = [];
                    
                    // Limit to top 100 candidates to check if list is still big
                    const candidatesToCheck = wordsNow.length > 100 ? wordsNow.slice(0, 100) : wordsNow;

                    const wordEntropies = candidatesToCheck.map(w => ({
                        word: w, 
                        entropy: calculateEntropy(w, wordsNow)
                    }));
                    
                    wordEntropies.sort((a, b) => b.entropy - a.entropy);
                    
                    // Pick from top 10%
                    const topN = Math.max(1, Math.floor(wordEntropies.length * 0.1));
                    const topCandidates = wordEntropies.slice(0, topN);
                    guessedWord = topCandidates[Math.floor(Math.random() * topCandidates.length)].word;
                }
            } else if (strategy === 'frequency') {
                let prob = randomPickProb[Math.floor(Math.random() * randomPickProb.length)];
                let topK = Math.max(1, Math.floor(wordsNow.length * prob));
                guessedWord = wordsNow[Math.floor(Math.random() * topK)];
            } else {
                // Random
                guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
            }
            guesses.push(guessedWord);
        }
        return { tries: 7, guesses };
    }

    // --- UI Logic ---

    let targetWord = "";
    let currentTry = 0;
    let wordsNow = [];
    let gameState = {
        yellowInfo: {},
        grayLetters: new Set(),
        yellowLetters: new Set(),
        greenLetters: new Set(),
        acceptWord: ['?', '?', '?', '?', '?'],
        gameOver: false
    };

    // Init Grid
    const gridEl = document.getElementById('grid');
    for (let i = 0; i < 30; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.id = `cell-${Math.floor(i/5)}-${i%5}`;
        gridEl.appendChild(cell);
    }

    // Init Chart
    const chartEl = document.getElementById('chart');
    const counts = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0}; // 7 is fail/7th
    
    function renderChart() {
        chartEl.innerHTML = '';
        const maxVal = Math.max(...Object.values(counts), 1);
        const maxBarHeight = 200; // Max height in pixels for the bar itself
        
        const colors = {
            1: '#1f77b4', // Blue
            2: '#ff7f0e', // Orange
            3: '#2ca02c', // Green
            4: '#d62728', // Red
            5: '#9467bd', // Purple
            6: '#8c564b', // Brown
            7: '#7f7f7f'  // Gray (Fail)
        };

        for (let i = 1; i <= 7; i++) {
            const count = counts[i];
            const heightPx = (count / maxVal) * maxBarHeight;
            
            const group = document.createElement('div');
            group.className = 'bar-group';
            
            const valDiv = document.createElement('div');
            valDiv.className = 'bar-value';
            valDiv.innerText = count;
            
            const bar = document.createElement('div');
            bar.className = 'bar';
            bar.style.height = `${heightPx}px`;
            bar.style.backgroundColor = colors[i];
            
            const label = document.createElement('div');
            label.className = 'bar-label';
            label.innerText = i === 7 ? 'Fail' : i;
            
            group.appendChild(valDiv);
            group.appendChild(bar);
            group.appendChild(label);
            chartEl.appendChild(group);
        }
    }
    renderChart();

    function setTarget() {
        const val = document.getElementById('targetWord').value.toLowerCase().trim();
        if (val.length !== 5 || !/^[a-z]+$/.test(val)) {
            alert("Invalid word");
            return;
        }
        targetWord = val;
        resetGame();
        document.getElementById('btnStep').disabled = false;
        document.getElementById('status').innerText = `Target set. Candidates: ${WORD_LIST.length}`;
    }

    function setRandomTarget() {
        const w = WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)];
        document.getElementById('targetWord').value = w;
        setTarget();
    }

    function resetGame() {
        currentTry = 0;
        wordsNow = [...WORD_LIST];
        gameState = {
            yellowInfo: {},
            grayLetters: new Set(),
            yellowLetters: new Set(),
            greenLetters: new Set(),
            acceptWord: ['?', '?', '?', '?', '?'],
            gameOver: false
        };
        
        // Clear grid
        document.querySelectorAll('.cell').forEach(c => {
            c.innerText = '';
            c.className = 'cell';
        });
    }

    function stepSimulation() {
        if (gameState.gameOver || currentTry >= 6) return;
        
        const strategy = document.getElementById('strategy').value;
        const randomPickProb = [0.2, 0.3, 0.5];
        
        if (wordsNow.length === 0) {
            document.getElementById('status').innerText = "No candidates left.";
            gameState.gameOver = true;
            return;
        }

        let guessedWord;
        
        // Logic for picking next word based on strategy
        if (strategy === 'entropy') {
            // For first guess or large lists, pick random to avoid freeze
            if (currentTry === 0 || wordsNow.length > 500) {
                guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
            } else {
                // Entropy calculation
                const candidatesToCheck = wordsNow.length > 100 ? wordsNow.slice(0, 100) : wordsNow;
                const wordEntropies = candidatesToCheck.map(w => ({
                    word: w, 
                    entropy: calculateEntropy(w, wordsNow)
                }));
                wordEntropies.sort((a, b) => b.entropy - a.entropy);
                const topN = Math.max(1, Math.floor(wordEntropies.length * 0.1));
                const topCandidates = wordEntropies.slice(0, topN);
                guessedWord = topCandidates[Math.floor(Math.random() * topCandidates.length)].word;
            }
        } else if (strategy === 'frequency') {
            const prob = randomPickProb[Math.floor(Math.random() * randomPickProb.length)];
            const topK = Math.max(1, Math.floor(wordsNow.length * prob));
            guessedWord = wordsNow[Math.floor(Math.random() * topK)];
        } else {
            // Random
            guessedWord = wordsNow[Math.floor(Math.random() * wordsNow.length)];
        }
        
        // Render guess
        for (let i = 0; i < 5; i++) {
            const cell = document.getElementById(`cell-${currentTry}-${i}`);
            cell.innerText = guessedWord[i];
        }
        
        if (guessedWord === targetWord) {
            for (let i = 0; i < 5; i++) {
                document.getElementById(`cell-${currentTry}-${i}`).classList.add('green');
            }
            document.getElementById('status').innerText = `Solved in ${currentTry + 1} tries!`;
            gameState.gameOver = true;
            return;
        }
        
        const feedback = getFeedback(guessedWord, targetWord);
        
        // Color grid & Update constraints
        for (let i = 0; i < 5; i++) {
            const color = feedback[i];
            const char = guessedWord[i];
            document.getElementById(`cell-${currentTry}-${i}`).classList.add(color);
            
            if (color === 'green') {
                gameState.acceptWord[i] = char;
                gameState.greenLetters.add(char);
            } else if (color === 'yellow') {
                gameState.yellowLetters.add(char);
                if (!gameState.yellowInfo[char]) gameState.yellowInfo[char] = [];
                gameState.yellowInfo[char].push(i);
            } else {
                gameState.grayLetters.add(char);
            }
        }
        
        if (strategy === 'entropy') {
             wordsNow = fitGray(gameState.grayLetters, gameState.yellowLetters, gameState.greenLetters, wordsNow);
        } else {
            wordsNow = fitGreen(gameState.acceptWord, wordsNow);
            wordsNow = fitYellow(gameState.yellowInfo, wordsNow);
            wordsNow = fitGray(gameState.grayLetters, gameState.yellowLetters, gameState.greenLetters, wordsNow);
        }
        
        wordsNow = wordsNow.filter(w => w !== guessedWord);
        
        currentTry++;
        document.getElementById('status').innerText = `Candidates left: ${wordsNow.length}`;
        
        if (currentTry >= 6 && !gameState.gameOver) {
            document.getElementById('status').innerText = "Failed.";
            gameState.gameOver = true;
        }
    }

    // --- Batch Logic ---
    
    let batchRunning = false;
    
    async function startBatch() {
        if (!targetWord) {
            alert("Set target word first!");
            return;
        }
        if (batchRunning) return;
        
        const count = parseInt(document.getElementById('batchCount').value);
        const speed = parseInt(document.getElementById('batchSpeed').value);
        const strategy = document.getElementById('strategy').value;
        
        batchRunning = true;
        document.getElementById('btnBatch').disabled = true;
        
        // Reset counts
        for(let k in counts) counts[k] = 0;
        renderChart();
        
        for (let i = 0; i < count; i++) {
            const result = runSimulationOnce(targetWord, WORD_LIST, strategy);
            counts[result.tries]++;
            
            // Update UI
            renderChart();
            document.getElementById('progressFill').style.width = `${((i+1)/count)*100}%`;
            document.getElementById('batchStatus').innerText = `Running ${i+1}/${count}`;
            
            if (speed > 0) {
                await new Promise(r => setTimeout(r, speed));
            }
        }
        
        batchRunning = false;
        document.getElementById('btnBatch').disabled = false;
        document.getElementById('batchStatus').innerText = "Done.";
    }

</script>

</body>
</html>
